## 오늘의 강의

### 자료구조 복습

- 더블 링크드 리스트 (DLL)
- Circula Doubley Linked List
- 노드 사이의 링크가 두개, 즉 서로 참조한다.
- 센티널을 쓰면 첫번째 노드와 마지막 노드를 찾기 쉽다.
- Binary Tree 구현 시 DLL을 이용하여 구현 할 수 있다.
- BST -> find (k) -> v : 최고 O(log n), 최악 O(n)
- HashMap -> hash : 최고 O(1), 최악 O(n)
- 보통 메모리용 자료구조로 사용하고, 디스크에서는 쓸 수 없다.

### DB에서 가장 중요한 자료구조

- B- Tree
- B+ Tree
- DB에서 가장 중요한, 검색을 위한 자료구조
- B-Tree가 BST와 다른 점? 노드 데이터가 2개 이상인 트리구조이다. (보통 4kb, 16kb. 즉 블록 사이즈로 맞추어져 있다.)
- 노드 데이터의 크기를 키운 이유는? 디스크는 물리적인 블록(페이지)단위이기 때문에 덩어리로 읽는다. (한번에 많이 저장해야 한다.)
- B+Tree는 Hash와 다르게 범위 검색이 가능하다.

### B-Tree

- Entry Sequence File을 이용하여 데이터 파일을 표현
- 레코드가 입력되는 순서대로 저장되는 파일. 즉, 정렬되어있지 않다.
- 정렬하려면 엄청난 오버헤드가 발생 할 수 있다.
- 인덱스를 참조하여 문제점을 해결 할 수 있다.
- 데이터가 루트에도 있을 수 있다.

### B+Tree

- Indexed Sequence File을 이용하여 데이터 파일을 표현
- 인덱스를 통해 데이터 파일의 각 레코드에 접근할 수 있으며, 데이터 파일의 레코드가 정렬된 순서로 저장되어 있는 구조를 갖고 있다. 즉, 데이터 파일의 레코드가 정렬되어 저장된다.
- 정렬하여 저장될 때 오버헤드를 줄이기 위해 Sequence Set을 사용한다.
- 모든 데이터가 리프에 있다. (루트에도 있고 리프에도 있고)
- 다음 페이지에 대한 참조를 갖고 있다.

### MySQL의 물리적 저장구조

- 인덱스 없이 DB를 검색하는 것? Full Scan
- DB에서 인덱스는 검색을 빠르게 하기 위한 자료구조이며, primary key를 만들면 자동으로 생성된다.
- Foreign key : 참조 무결성 제약 조건 -> primary key에 존재하는 값이나, NULL 값이 들어 갈 수 있다. 인덱스 자동생성된다.
- Unique 제약조건 역시 내부적으로 인덱스가 자동 생성된다.
- 페이지 기반 저장, 한 글자 고치더라도 한 페이지(16kb) 수정된다.
- 레코드 vs. 컬럼 : 주로 레코드 기반 저장이다.
- 고정길이 vs. 가변길이 : 가변길이
- PK 순서대로 정렬? 입력되는 순서대로 쌓는다 1 -> 3 -> 4 (2 추가하면? 1 -> 3 -> 4 -> 2)
- 실제 데이터는 순차적으로 Heap File로 저장된다.
- PK에 대한 B+Tree 인덱스를 만들고, Clustered Index 구조로 저장한다. (링크드 리스트와 같이 주속값을 참조한다.)
- 인덱스는 데이터의 페이지(블록)을 참조한다. 실제로는 RID (Page Number + Record Number)를 참조한다.
- 레코드는 순차적으로 저장되며, pk를 이용한다. 세컨더리는 pk를 이용하여 접근한다.
- 결론 : 컬럼에 인덱스를 걸면 검색이 빨라지고 삽입은 느려진다.
- DB 인덱스를 만들어 볼까



#### 참고 링크

- https://untitledtblog.tistory.com/80
